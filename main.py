import openai
import json
import os

def read_case_history(file_path):
    """
    Reads and loads the case history from a text file.
    
    Parameters:
        file_path (str): The path to the file containing the case history.
    
    Returns:
        str: The contents of the file as a single string.
    """
    with open(file_path, 'r') as f:
        data = f.read()
    return data

def create_patient_profile(case_history):
    """
    Uses the OpenAI API to create a patient profile by extracting key information
    from the provided case history.
    
    Parameters:
        case_history (str): The raw text of the patient case history.
    
    Returns:
        str: A summary patient profile generated by the AI.
    """
    prompt = (
        "Extract important patient information (e.g., age, gender, symptoms, medical history, "
        "and relevant clinical findings) from the following case history and create a detailed summary profile:\n\n"
        f"{case_history}\n\nPatient Profile:"
    )
    
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are a helpful medical assistant."},
            {"role": "user", "content": prompt}
        ],
        temperature=0.5,
    )
    
    # Extract the generated patient profile from the API response.
    patient_profile = response.choices[0].message.content.strip()
    return patient_profile

def create_conceptual_knowledge_graph(patient_profile):
    """
    Uses the OpenAI API to create a conceptual knowledge graph (CKG) based on the patient profile.
    The graph includes nodes (medical entities), edges (relationships), and weights (relationship strengths).
    
    Parameters:
        patient_profile (str): The summary patient profile.
    
    Returns:
        dict: A dictionary representing the conceptual knowledge graph with keys 'nodes' and 'edges'.
    """
    prompt = (
        "Based on the following patient profile, generate a conceptual knowledge graph (CKG) in JSON format. "
        "The CKG should include:\n"
        "- Nodes representing relevant medical entities (e.g., symptoms, diagnoses, lab values, conditions).\n"
        "- Edges representing relationships between these nodes (e.g., 'leads to', 'associated with').\n"
        "- Weights for each edge (as a float value between 0 and 1 indicating the strength of the relationship).\n\n"
        f"Patient Profile:\n{patient_profile}\n\n"
        "Output the result as JSON with keys: 'nodes' and 'edges'. "
        "'nodes' should be a list of objects with 'id' and 'label'. "
        "'edges' should be a list of objects with 'source', 'target', and 'weight'."
    )
    
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are a knowledgeable assistant in medical data analysis."},
            {"role": "user", "content": prompt}
        ],
        temperature=0.5,
    )
    
    ckg_json_str = response.choices[0].message.content.strip()
    try:
        ckg = json.loads(ckg_json_str)
    except json.JSONDecodeError:
        print("Error decoding JSON from OpenAI API response. Here is the response:")
        print(ckg_json_str)
        ckg = {}
    return ckg

def tune_knowledge_graph(ckg):
    """
    Provides an interactive tuning step for the conceptual knowledge graph (CKG).
    The user may add or modify nodes and edges (including their weights).
    
    Parameters:
        ckg (dict): The initial conceptual knowledge graph.
    
    Returns:
        dict: The modified (tuned) conceptual knowledge graph.
    """
    print("\nCurrent Knowledge Graph:")
    print(json.dumps(ckg, indent=2))
    print("\nWould you like to alter the knowledge graph? (yes/no)")
    choice = input().strip().lower()
    
    if choice == "yes":
        # Loop to allow multiple modifications.
        while True:
            print("\nEnter the type of modification you want to make (node, edge) or type 'done' to finish:")
            mod_type = input().strip().lower()
            if mod_type == "done":
                break
            elif mod_type == "node":
                print("Enter 'add' to add a new node or 'modify' to modify an existing node:")
                action = input().strip().lower()
                if action == "add":
                    print("Enter new node id:")
                    node_id = input().strip()
                    print("Enter new node label:")
                    node_label = input().strip()
                    ckg.setdefault("nodes", []).append({"id": node_id, "label": node_label})
                elif action == "modify":
                    print("Enter the node id to modify:")
                    node_id = input().strip()
                    found = False
                    for node in ckg.get("nodes", []):
                        if node["id"] == node_id:
                            found = True
                            print(f"Current label: {node['label']}. Enter new label:")
                            new_label = input().strip()
                            node["label"] = new_label
                            break
                    if not found:
                        print("Node id not found.")
            elif mod_type == "edge":
                print("Enter 'add' to add a new edge or 'modify' to modify an existing edge:")
                action = input().strip().lower()
                if action == "add":
                    print("Enter source node id:")
                    source = input().strip()
                    print("Enter target node id:")
                    target = input().strip()
                    print("Enter weight (0 to 1):")
                    weight = float(input().strip())
                    ckg.setdefault("edges", []).append({"source": source, "target": target, "weight": weight})
                elif action == "modify":
                    print("Enter source node id of the edge to modify:")
                    source = input().strip()
                    print("Enter target node id of the edge to modify:")
                    target = input().strip()
                    found = False
                    for edge in ckg.get("edges", []):
                        if edge["source"] == source and edge["target"] == target:
                            found = True
                            print(f"Current weight: {edge['weight']}. Enter new weight (0 to 1):")
                            new_weight = float(input().strip())
                            edge["weight"] = new_weight
                            break
                    if not found:
                        print("Edge not found.")
            else:
                print("Invalid modification type. Please choose again.")
        print("\nFinal tuned Knowledge Graph:")
        print(json.dumps(ckg, indent=2))
    else:
        print("No modifications made.")
    
    return ckg

def find_differential_diagnosis(ckg):
    """
    Uses the OpenAI API to generate a list of differential diagnoses based on the conceptual knowledge graph (CKG).
    The response includes both a set of differential diagnoses with explanations and a recommended final diagnosis.
    
    Parameters:
        ckg (dict): The conceptual knowledge graph.
    
    Returns:
        dict: A JSON/dictionary containing differential diagnoses and the final diagnosis.
    """
    prompt = (
        "Given the following conceptual knowledge graph in JSON format that represents the patient's case information, "
        "generate a list of differential diagnoses along with a brief explanation for each. Finally, recommend the most likely final diagnosis.\n\n"
        "Knowledge Graph:\n"
        f"{json.dumps(ckg, indent=2)}\n\n"
        "Output the result as JSON with keys 'differential_diagnoses' (a list of objects with 'diagnosis' and 'explanation') and 'final_diagnosis'."
    )
    
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are a medical diagnostic assistant."},
            {"role": "user", "content": prompt}
        ],
        temperature=0.5,
    )
    
    diagnosis_json_str = response.choices[0].message.content.strip()
    try:
        diagnosis = json.loads(diagnosis_json_str)
    except json.JSONDecodeError:
        print("Error decoding JSON for differential diagnosis. Here is the response:")
        print(diagnosis_json_str)
        diagnosis = {}
    return diagnosis

def main():
    """
    Main function to run the entire diagnostic process:
    1. Load patient case history.
    2. Create a patient profile.
    3. Generate a conceptual knowledge graph.
    4. Allow interactive tuning of the knowledge graph.
    5. Generate differential diagnoses and a final diagnosis.
    """
    # Set up your OpenAI API key.
    openai.api_key = os.getenv("OPENAI_API_KEY")
    if not openai.api_key:
        print("Please set your OPENAI_API_KEY environment variable.")
        return

    # PART 1: Read and load patient case history from a file.
    file_path = "patient_case_history.txt"  # Ensure this file exists in the same directory.
    print("Loading patient case history from file...")
    case_history = read_case_history(file_path)
    print("Case history loaded.\n")

    # Create patient profile using OpenAI API.
    print("Creating patient profile...")
    patient_profile = create_patient_profile(case_history)
    print("\n--- Patient Profile ---")
    print(patient_profile)

    # Create conceptual knowledge graph using OpenAI API.
    print("\nCreating conceptual knowledge graph (CKG)...")
    ckg = create_conceptual_knowledge_graph(patient_profile)
    print("\n--- Initial Conceptual Knowledge Graph ---")
    print(json.dumps(ckg, indent=2))

    # Provide a tuning step for the knowledge graph.
    tuned_ckg = tune_knowledge_graph(ckg)

    # Use the tuned knowledge graph to generate differential diagnoses.
    print("\nFinding differential diagnosis based on the knowledge graph...")
    diagnosis = find_differential_diagnosis(tuned_ckg)
    print("\n--- Differential Diagnosis and Final Diagnosis ---")
    print(json.dumps(diagnosis, indent=2))

if __name__ == "__main__":
    main()
